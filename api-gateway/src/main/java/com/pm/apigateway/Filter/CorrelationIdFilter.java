package com.pm.apigateway.Filter;

import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpHeaders;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;
import org.slf4j.MDC; // Import MDC

import java.util.List;
import java.util.UUID;

@Component
public class CorrelationIdFilter implements GlobalFilter, Ordered {

    private static final String CORRELATION_ID_HEADER = "X-Correlation-ID";
    private static final String CORRELATION_ID_MDC_KEY = "correlationId"; // Key for logging context

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String correlationId = getOrGenerateCorrelationId(request.getHeaders());

        // Add Correlation ID to request headers for downstream services
        ServerHttpRequest mutatedRequest = request.mutate()
                .header(CORRELATION_ID_HEADER, correlationId)
                .build();

        // Add Correlation ID to response headers for the client
        exchange.getResponse().getHeaders().add(CORRELATION_ID_HEADER, correlationId);

        // Add to logging context (MDC) for logs generated by the gateway itself
        // Use contextWrite for reactive context propagation if needed deeper, but MDC often works for simple logging here
        return chain.filter(exchange.mutate().request(mutatedRequest).build())
                .contextWrite(ctx -> ctx.put(CORRELATION_ID_MDC_KEY, correlationId)) // Optional: For reactive context
                .doOnSubscribe(subscription -> { // Set MDC for synchronous logging within this filter chain processing
                    MDC.put(CORRELATION_ID_MDC_KEY, correlationId);
                })
                .doFinally(signalType -> { // Clean up MDC
                    MDC.remove(CORRELATION_ID_MDC_KEY);
                });
    }

    private String getOrGenerateCorrelationId(HttpHeaders headers) {
        List<String> correlationIds = headers.get(CORRELATION_ID_HEADER);
        if (correlationIds == null || correlationIds.isEmpty()) {
            return UUID.randomUUID().toString();
        }
        return correlationIds.get(0);
    }

    @Override
    public int getOrder() {
        // Run before most other filters, especially routing
        return Ordered.HIGHEST_PRECEDENCE;
    }
}