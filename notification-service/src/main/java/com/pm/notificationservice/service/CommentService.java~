package com.pm.notificationservice.service;

import com.pm.contracts.dto.UserDto; // Need UserDTO for user details
import com.pm.contracts.envelope.EventEnvelope;
import com.pm.contracts.events.notification.NotificationToSendEventPayload;
import com.pm.contracts.events.task.TaskAssignedEventPayload; // Example consumed payload
import com.pm.contracts.events.task.TaskStatusChangedEventPayload; // Example
import com.pm.notificationservice.config.MdcLoggingFilter;
import com.pm.notificationservice.model.Notification;
import com.pm.notificationservice.repository.NotificationRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.core.reactive.ReactiveKafkaProducerTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient; // For calling user-service
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.context.ContextView;

import java.util.List;
import java.util.Objects;

@Service
public class NotificationService {
    private static final Logger log = LoggerFactory.getLogger(NotificationService.class);

    private final NotificationRepository notificationRepository;
    private final ReactiveKafkaProducerTemplate<String, EventEnvelope<?>> kafkaTemplate;
    private final WebClient userWebClient; // WebClient for user-service

    @Value("${spring.application.name}") private String serviceName;
    @Value("${kafka.topic.notification-dispatch}") private String dispatchTopic;

    // Constructor injection...
    public NotificationService(NotificationRepository notificationRepository,
                               ReactiveKafkaProducerTemplate<String, EventEnvelope<?>> kafkaTemplate,
                               @Qualifier("userWebClient") WebClient userWebClient) { // Qualify if multiple WebClients exist
        this.notificationRepository = notificationRepository;
        this.kafkaTemplate = kafkaTemplate;
        this.userWebClient = userWebClient;
    }

    // Central method to process incoming business events
    public Mono<Void> processIncomingEvent(EventEnvelope<?> incomingEnvelope) {
        return Mono.deferContextual(contextView -> {
            String correlationId = contextView.getOrDefault(MdcLoggingFilter.CORRELATION_ID_CONTEXT_KEY, "N/A-event");
            log.debug("Processing incoming event. Type: {}, CorrID: {}", incomingEnvelope.eventType(), correlationId);

            // Determine recipients and message based on event type
            return generateNotificationsFromEvent(incomingEnvelope, correlationId)
                    .flatMap(notification -> saveAndTriggerDispatch(notification, correlationId))
                    .then(); // Consume the results and return Mono<Void>
        });
    }

    // Logic to decide who to notify and what the message is
    private Flux<Notification> generateNotificationsFromEvent(EventEnvelope<?> envelope, String correlationId) {
        Object payload = envelope.payload();

        // --- Example: Task Assigned --- giải quyết lấy assignee id từ user service chứ assigned to lấy ra tên
        if (payload instanceof TaskAssignedEventPayload taskAssigned) {
            String assigneeId = taskAssigned.taskDto().getAssignedTo();
            if (assigneeId == null) return Flux.empty(); // No assignee, no notification

            String taskId = taskAssigned.taskDto().getId();
            String taskName = taskAssigned.updatedTaskData().name(); // Assuming name is in DTO
            String projectId = taskAssigned.updatedTaskData().projectId();

            String message = String.format("You were assigned task '%s' in project %s.", taskName, projectId); // Simple format

            // Create notification for WebSocket channel
            Notification wsNotification = new Notification(assigneeId, envelope.eventType(), message, "TASK", taskId, Notification.NotificationChannel.WEBSOCKET);

            // Potentially create one for Email too (requires fetching user email)
            // Mono<Notification> emailNotificationMono = createEmailNotification(...)

            return Flux.just(wsNotification); // Return Flux of notifications to create
        }
        // --- Example: Task Status Changed ---
        else if (payload instanceof TaskStatusChangedEventPayload taskStatusChanged) {
            // Notify project members? Or just assignee? Depends on requirements.
            // Let's assume notify assignee if status becomes BLOCKED
            if (taskStatusChanged.updatedTaskData().status() == com.yourproject.contracts.domain.TaskStatus.BLOCKED) {
                String assigneeId = taskStatusChanged.updatedTaskData().assigneeId();
                if (assigneeId == null) return Flux.empty();

                String taskId = taskStatusChanged.updatedTaskData().id();
                String taskName = taskStatusChanged.updatedTaskData().name();
                String message = String.format("Task '%s' you are assigned to was marked as BLOCKED.", taskName);
                Notification wsNotification = new Notification(assigneeId, envelope.eventType(), message, "TASK", taskId, Notification.NotificationChannel.WEBSOCKET);
                return Flux.just(wsNotification);
            }
            return Flux.empty(); // No notification for other status changes in this example
        }

        // --- Add logic for other event types (ProjectCreated, UserAddedToProject, etc.) ---
        // You might need to call user-service here to get project members etc.

        else {
            log.warn("Unhandled event type for notification generation: {}. CorrID: {}", envelope.eventType(), correlationId);
            return Flux.empty(); // No notification for unhandled types
        }
    }

    // Save notification to DB and publish dispatch event
    private Mono<Void> saveAndTriggerDispatch(Notification notification, String correlationId) {
        return notificationRepository.save(notification)
                .doOnSuccess(savedNotification -> {
                    log.info("Saved notification {}. Triggering dispatch. CorrID: {}", savedNotification.getId(), correlationId);
                    publishDispatchEvent(savedNotification, correlationId);
                })
                .doOnError(e -> log.error("Failed to save notification for user {}. CorrID: {}", notification.getRecipientUserId(), correlationId, e))
                .then(); // Convert to Mono<Void>
    }

    // Publish event to trigger actual sending by websocket-service or email-service
    private void publishDispatchEvent(Notification notification, String correlationId) {
        NotificationToSendEventPayload dispatchPayload = new NotificationToSendEventPayload(
                notification.getId(),
                notification.getRecipientUserId(),
                notification.getMessage(),
                notification.getChannel().name(), // "WEBSOCKET" or "EMAIL"
                correlationId // Pass correlation ID along
        );

        EventEnvelope<NotificationToSendEventPayload> dispatchEnvelope = new EventEnvelope<>(
                correlationId, // Use the same correlation ID
                NotificationToSendEventPayload.TYPE,
                serviceName, // Source is notification-service
                dispatchPayload
        );

        kafkaTemplate.send(dispatchTopic, notification.getRecipientUserId(), dispatchEnvelope) // Key by recipient ID?
                .doOnError(e -> log.error("Failed to publish NotificationToSendEvent. NotifID: {}, CorrID: {}", notification.getId(), correlationId, e))
                .subscribe();
    }

    // --- Helper to call User Service (Example) ---
    // This would be used within generateNotificationsFromEvent if needed
    private Mono<UserDTO> getUserDetails(String userId, String correlationId) {
        log.debug("Fetching user details for ID: {}. CorrID: {}", userId, correlationId);
        return userWebClient.get()
                .uri("/{id}", userId) // Path relative to base URL configured
                .header(MdcLoggingFilter.CORRELATION_ID_HEADER, correlationId) // Pass Correlation ID
                .retrieve()
                .bodyToMono(UserDTO.class)
                .doOnError(e -> log.error("Failed to fetch user details for ID: {}. CorrID: {}", userId, correlationId, e))
                .onErrorResume(e -> Mono.empty()); // Handle error gracefully, maybe return empty
    }
}