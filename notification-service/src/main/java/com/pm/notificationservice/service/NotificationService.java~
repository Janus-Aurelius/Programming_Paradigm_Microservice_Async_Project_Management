package com.pm.notificationservice.service;

import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.core.reactive.ReactiveKafkaProducerTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import com.pm.commoncontracts.domain.TaskStatus;
import com.pm.commoncontracts.dto.CommentDto;
import com.pm.commoncontracts.dto.NotificationDto;
import com.pm.commoncontracts.dto.TaskDto;
import com.pm.commoncontracts.dto.UserDto;
import com.pm.commoncontracts.envelope.EventEnvelope;
import com.pm.commoncontracts.events.comment.CommentAddedEventPayload;
import com.pm.commoncontracts.events.notification.NotificationToSendEventPayload;
import com.pm.commoncontracts.events.project.ProjectCreatedEventPayload;
import com.pm.commoncontracts.events.project.ProjectTaskCreatedEventPayload;
import com.pm.commoncontracts.events.task.TaskAssignedEventPayload;
import com.pm.commoncontracts.events.task.TaskCreatedEventPayload;
import com.pm.commoncontracts.events.task.TaskPriorityChangedEventPayload;
import com.pm.commoncontracts.events.task.TaskStatusChangedEventPayload;
import com.pm.commoncontracts.events.task.TaskUpdatedEventPayload;
import com.pm.notificationservice.config.MdcLoggingFilter;
import com.pm.notificationservice.model.Notification;
import com.pm.notificationservice.repository.NotificationRepository;
import com.pm.notificationservice.utils.MentionUtils;
import com.pm.notificationservice.utils.NotificationUtils;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;


@Service
public class NotificationService {
    private static final Logger logger = LoggerFactory.getLogger(NotificationService.class);
    
    private final NotificationRepository notificationRepository;
    private final ReactiveKafkaProducerTemplate<String, EventEnvelope<?>> kafkaTemplate;
    private final WebClient taskWebClient;
    private final WebClient projectWebClient;

    @Value("${spring.application.name}") 
    private String serviceName;
    
    @Value("${kafka.topic.notification-dispatch}") 
    private String dispatchTopic;

    public NotificationService(
            NotificationRepository notificationRepository,
            ReactiveKafkaProducerTemplate<String, EventEnvelope<?>> kafkaTemplate,
            @Qualifier("taskWebClient") WebClient taskWebClient,
            @Qualifier("projectWebClient") WebClient projectWebClient) {
        this.notificationRepository = notificationRepository;
        this.kafkaTemplate = kafkaTemplate;
        this.taskWebClient = taskWebClient;
        this.projectWebClient = projectWebClient;
    }

    // Central method to process incoming business events
    public Mono<Void> processIncomingEvent(EventEnvelope<?> incomingEnvelope) {
        return Mono.deferContextual(contextView -> {
            String correlationId = contextView.getOrDefault(MdcLoggingFilter.CORRELATION_ID_CONTEXT_KEY, "N/A-event");
            logger.debug("Processing incoming event. Type: {}, CorrID: {}", incomingEnvelope.eventType(), correlationId);

            return generateNotificationsFromEvent(incomingEnvelope, correlationId)
                    .flatMap(notification -> saveAndTriggerDispatch(notification, correlationId))
                    .then();
        });
    }

    private Flux<Notification> generateNotificationsFromEvent(EventEnvelope<?> envelope, String correlationId) {
        Object payload = envelope.payload();

        try {
            if (payload instanceof TaskAssignedEventPayload taskAssignedEventPayload) {
                return handleTaskAssignedEvent(taskAssignedEventPayload, envelope.eventType());
            }
            if (payload instanceof TaskStatusChangedEventPayload taskStatusChangedEventPayload) {
                return handleTaskStatusChangedEvent(taskStatusChangedEventPayload, envelope.eventType());
            }
            if (payload instanceof CommentAddedEventPayload commentAddedEventPayload) {
                return handleCommentAddedEvent(commentAddedEventPayload, envelope.eventType(), correlationId);
            }
            if (payload instanceof ProjectCreatedEventPayload projectCreatedEventPayload) {
                return handleProjectCreatedEvent(projectCreatedEventPayload, envelope.eventType());
            }
            if (payload instanceof ProjectTaskCreatedEventPayload projectTaskCreatedEventPayload) {
                return handleProjectTaskCreatedEvent(projectTaskCreatedEventPayload, envelope.eventType());
            }
            if (payload instanceof TaskCreatedEventPayload taskCreatedEventPayload) {
                return handleTaskCreatedEvent(taskCreatedEventPayload, envelope.eventType());
            }
            if (payload instanceof TaskUpdatedEventPayload taskUpdatedEventPayload) {
                return handleTaskUpdatedEvent(taskUpdatedEventPayload, envelope.eventType());
            }
            if (payload instanceof TaskPriorityChangedEventPayload taskPriorityChangedEventPayload) {
                return handleTaskPriorityChangedEvent(taskPriorityChangedEventPayload, envelope.eventType());
            }
            // ProjectUpdatedEventPayload, ProjectStatusChangedEventPayload: no notification per your rule
            // ProjectDeletedEventPayload, UserCreatedEventPayload, UserUpdatedEventPayload: ignored

            logger.warn("Unhandled event type for notification generation: {}. CorrID: {}", 
                envelope.eventType(), correlationId);
            return Flux.empty();
        } catch (Exception e) {
            logger.error("Error generating notifications for event type: {}. CorrID: {}", 
                envelope.eventType(), correlationId, e);
            return Flux.empty();
        }
    }

    // --- Event Handlers ---
    private Flux<Notification> handleTaskAssignedEvent(TaskAssignedEventPayload taskAssigned, String eventType) {
        TaskDto taskDto = taskAssigned.taskDto();
        String assigneeId = taskDto.getAssigneeId();
        
        if (assigneeId == null) {
            logger.warn("Task {} was assigned but has no assignee ID", taskDto.getId());
            return Flux.empty();
        }

        String taskName = taskDto.getName();
        String message = String.format("Task '%s' was assigned to you", taskName);
        
        return Flux.just(new Notification(
            assigneeId,
            eventType,
            message,
            "TASK",
            taskDto.getId(),
            Notification.NotificationChannel.WEBSOCKET
        ));
    }

    private Flux<Notification> handleTaskStatusChangedEvent(TaskStatusChangedEventPayload taskStatusChanged, String eventType) {
        TaskDto updatedTask = taskStatusChanged.taskDto();
        
        if (updatedTask.getStatus() == TaskStatus.BLOCKED) {
            String assigneeId = updatedTask.getAssigneeId();
            if (assigneeId == null) {
                logger.warn("Task {} status changed to BLOCKED but has no assignee ID", updatedTask.getId());
                return Flux.empty();
            }

            String taskName = updatedTask.getName();
            String message = String.format("Task '%s' you are assigned to was marked as BLOCKED", taskName);
            
            return Flux.just(new Notification(
                assigneeId,
                eventType,
                message,
                "TASK",
                updatedTask.getId(),
                Notification.NotificationChannel.WEBSOCKET
            ));
        }
        
        return Flux.empty();
    }

    private Flux<Notification> handleCommentAddedEvent(CommentAddedEventPayload commentAdded, 
            String eventType, String correlationId) {
        CommentDto commentDto = commentAdded.commentDto();
        String parentId = commentDto.getParentId();
        String parentType = commentDto.getParentType().name();
        String authorUsername = commentDto.getUsername();
        String commentId = commentDto.getId();
        String commentText = commentDto.getContent();
        Set<String> mentionedUsernames = MentionUtils.extractMentions(commentText);

        logger.info("CommentAddedEvent received for {} {}. Author: {}. CorrID: {}", 
            parentType, parentId, authorUsername, correlationId);

        if ("TASK".equals(parentType)) {
            return getTaskCommentNotifications(parentId, authorUsername, commentId, eventType, mentionedUsernames);
        } else if ("PROJECT".equals(parentType)) {
            return getProjectCommentNotifications(parentId, authorUsername, commentId, eventType, mentionedUsernames);
        }

        return Flux.empty();
    }

    private Flux<Notification> handleProjectCreatedEvent(ProjectCreatedEventPayload payload, String eventType) {
        // Notify only initial assignees if any (e.g., project lead/owner in ProjectDto)
        var projectDto = payload.projectDto();
        // Example: if ProjectDto has getOwnerId()
        if (projectDto.getOwnerId() != null) {
            String message = String.format("You have been assigned as owner of the new project '%s'", projectDto.getName());
            return Flux.just(new Notification(
                projectDto.getOwnerId(),
                eventType,
                message,
                "PROJECT",
                projectDto.getId(),
                Notification.NotificationChannel.WEBSOCKET
            ));
        }
        return Flux.empty();
    }

    private Flux<Notification> handleProjectTaskCreatedEvent(ProjectTaskCreatedEventPayload payload, String eventType) {
        var taskDto = payload.taskDto();
        String assigneeId = taskDto.getAssigneeId();
        if (assigneeId != null) {
            String message = String.format("A new task '%s' has been assigned to you in project", taskDto.getName());
            return Flux.just(new Notification(
                assigneeId,
                eventType,
                message,
                "TASK",
                taskDto.getId(),
                Notification.NotificationChannel.WEBSOCKET
            ));
        }
        return Flux.empty();
    }

    private Flux<Notification> handleTaskCreatedEvent(TaskCreatedEventPayload payload, String eventType) {
        var taskDto = payload.taskDto();
        return notifyAssigneeOnly(taskDto, eventType, String.format("A new task '%s' has been assigned to you", taskDto.getName()), "TASK");
    }

    private Flux<Notification> handleTaskUpdatedEvent(TaskUpdatedEventPayload payload, String eventType) {
        var taskDto = payload.taskDto();
        return notifyAssigneeOnly(taskDto, eventType, String.format("Task '%s' was updated", taskDto.getName()), "TASK");
    }

    private Flux<Notification> handleTaskPriorityChangedEvent(TaskPriorityChangedEventPayload payload, String eventType) {
        var taskDto = payload.dto();
        return notifyAssigneeOnly(taskDto, eventType, String.format("Priority of task '%s' was changed", taskDto.getName()), "TASK");
    }

    // Helper: Notify only the assignee
    private Flux<Notification> notifyAssigneeOnly(TaskDto taskDto, String eventType, String message, String type) {
        String assigneeId = taskDto.getAssigneeId();
        if (assigneeId != null) {
            return Flux.just(new Notification(
                assigneeId,
                eventType,
                message,
                type,
                taskDto.getId(),
                Notification.NotificationChannel.WEBSOCKET
            ));
        }
        return Flux.empty();
    }

    /**
     * Notify task assignee if mentioned or if not the author. Mentioned users get a special message.
     */
    private Flux<Notification> getTaskCommentNotifications(String taskId, String authorUsername, 
            String commentId, String eventType, Set<String> mentionedUsernames) {
        return taskWebClient.get()
            .uri("/api/tasks/{taskId}", taskId)
            .retrieve()
            .bodyToMono(TaskDto.class)
            .flatMapMany(task -> {
                String assigneeId = task.getAssigneeId();
                String assigneeUsername = task.getAssigneeName();
                if (assigneeId == null || assigneeUsername == null || assigneeUsername.equals(authorUsername)) {
                    return Flux.empty();
                }
                if (mentionedUsernames.contains(assigneeUsername)) {
                    String message = String.format("%s mentioned you in a comment on task '%s'", authorUsername, task.getName());
                    return Flux.just(new Notification(
                        assigneeId,
                        eventType,
                        message,
                        "COMMENT",
                        commentId,
                        Notification.NotificationChannel.WEBSOCKET
                    ));
                } else {
                    String message = String.format("%s commented on task '%s'", authorUsername, task.getName());
                    return Flux.just(new Notification(
                        assigneeId,
                        eventType,
                        message,
                        "COMMENT",
                        commentId,
                        Notification.NotificationChannel.WEBSOCKET
                    ));
                }
            })
            .onErrorResume(e -> {
                logger.error("Error fetching task details for comment notification: {}", e.getMessage());
                return Flux.empty();
            });
    }

    /**
     * Notify all project members except the author. If there are no mentions, all members get a standard notification.
     * If there are mentions, mentioned users get a special message, others get a standard message.
     */
    private Flux<Notification> getProjectCommentNotifications(String projectId, String authorUsername, 
            String commentId, String eventType, Set<String> mentionedUsernames) {
        return projectWebClient.get()
            .uri("/api/projects/{projectId}/members", projectId)
            .retrieve()
            .bodyToFlux(UserDto.class)
            .filter(member -> !authorUsername.equals(member.getUsername()))
            .flatMap(member -> {
                String message;
                if (!mentionedUsernames.isEmpty() && mentionedUsernames.contains(member.getUsername())) {
                    message = String.format("%s mentioned you in a comment on project", authorUsername);
                } else {
                    message = String.format("%s commented on project", authorUsername);
                }
                return Flux.just(new Notification(
                    member.getId(),
                    eventType,
                    message,
                    "COMMENT",
                    commentId,
                    Notification.NotificationChannel.WEBSOCKET
                ));
            })
            .onErrorResume(e -> {
                logger.error("Error fetching project members for comment notification: {}", e.getMessage());
                return Flux.empty();
            });
    }

    private Mono<Void> saveAndTriggerDispatch(Notification notification, String correlationId) {
        return notificationRepository.save(notification)
                .doOnSuccess(savedNotification -> {
                    logger.info("Saved notification {}. Triggering dispatch. CorrID: {}", 
                        savedNotification.getId(), correlationId);
                    publishDispatchEvent(savedNotification, correlationId);
                })
                .doOnError(e -> logger.error("Failed to save notification for user {}. CorrID: {}", 
                    notification.getRecipientUserId(), correlationId, e))
                .then();
    }

    private void publishDispatchEvent(Notification notification, String correlationId) {
        NotificationToSendEventPayload dispatchPayload = new NotificationToSendEventPayload(
                NotificationUtils.entityToDto(notification),
                correlationId
        );
        EventEnvelope<NotificationToSendEventPayload> dispatchEnvelope = new EventEnvelope<>(
                correlationId,
                NotificationToSendEventPayload.EVENT_TYPE,
                serviceName,
                dispatchPayload
        );
        kafkaTemplate.send(dispatchTopic, notification.getRecipientUserId(), dispatchEnvelope)
                .doOnError(e -> logger.error("Failed to publish NotificationToSendEvent. NotifID: {}, CorrID: {}", 
                    notification.getId(), correlationId, e))
                .subscribe();
    }

    public Flux<NotificationDto> getNotificationsForUser(String recipientUserId) {
        return notificationRepository.findByUserId(recipientUserId)
                .map(NotificationUtils::entityToDto);
    }

    public Mono<Void> markNotificationRead(String notificationId, String userId) {
        return notificationRepository.findById(notificationId)
                .filter(n -> n.getRecipientUserId().equals(userId))
                .flatMap(notification -> {
                    notification.setRead(true);
                    return notificationRepository.save(notification).then();
                })
                .then();
    }
}